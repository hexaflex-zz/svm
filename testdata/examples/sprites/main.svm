;
; svm-asm -include testdata -out testdata/test.a -debug examples/sprites/main.svm
; svm-fdd -out testdata/test.img testdata/test.a
; svm -debug testdata/test.img
;

include "sys/fd35.svm"
include "sys/sprdi.svm"
include "sys/gp14.svm"
include "sys/clock.svm"

;------------------------------------------------------------------------------
; Program entrypoint.
;------------------------------------------------------------------------------
:main {
    call $setup

:loop
    gp14.JmpOnJustPressed $gp14.ButtonBack, $exit                              ; Exit the program if ButtonBack is pressed.
    gp14.CallOnJustPressed $gp14.ButtonA, $recolor                             ; Set text color to something random iff ButtonA was pressed.

    mov r0, $sprdi.Swap                                                        ; Present backbuffer.
    int sprdi.Device
    jmp $loop

:exit
    halt
}

;------------------------------------------------------------------------------
; setup initializes various devices properties.
;------------------------------------------------------------------------------
:setup {
    hwa fd35.Device, $fd35.Manufacturer, $fd35.Serial                          ; Find the device index for the floppy disk drive.
    jez $deviceNotFound

    hwa sprdi.Device, $sprdi.Manufacturer, $sprdi.Serial                       ; Find the device index for the display.
    jez $deviceNotFound

    hwa gp14.Device, $gp14.Manufacturer, $gp14.Serial                          ; Find the device index for the gamepad.
    jez $deviceNotFound

    hwa clock.Device, $clock.Manufacturer, $clock.Serial                       ; Find the device index for the clock.
    jez $deviceNotFound

    fd35.SyncReadSector $(1 * fd35.SectorByteSize), $1                         ; Load extra sectors into memory. We are currently lacking some font sprites.
    fd35.SyncReadSector $(2 * fd35.SectorByteSize), $2
    fd35.SyncReadSector $(3 * fd35.SectorByteSize), $3
    fd35.SyncReadSector $(4 * fd35.SectorByteSize), $4

    mov r0, $sprdi.SetBackgroundPalette                                        ; Load custom background color palette.
    mov r1, $palette
    int sprdi.Device

    mov r0, $sprdi.SetBackgroundSprites                                        ; Load our font. Text sprites are loaded into the background for
    mov r1, $font.Sprites                                                      ; this example, so we don't have to handle per-sprite positioning.
    mov r2, $font.ASCIIOffset                                                  ; They are aligned to a 2D grid.
    mov r3, $font.SpriteCount
    int sprdi.Device

    mov r0, $sprdi.DrawBackground                                              ; Display text at center of display.
    mov r1, $str_helloWorld
    mov r2, $(14 * 32 + 10)
    mov r3, $len_helloWorld
    int sprdi.Device
    ret

:deviceNotFound
    halt
}


;------------------------------------------------------------------------------
; recolor changes the last color in the background palette to a random value.
; This is the color used by our font sprites.
;------------------------------------------------------------------------------
:recolor {
    rng8 palette+45, $0, $16#ff                                                 ; Set the last palette color to something random.
    rng8 palette+46, $0, $16#ff
    rng8 palette+47, $0, $16#ff
    mov  r0, $sprdi.SetBackgroundPalette                                        ; reload background color palette.
    mov  r1, $palette
    int  sprdi.Device
    ret
}

;------------------------------------------------------------------------------
; Variables & embedded data
;------------------------------------------------------------------------------
const len_helloWorld = 13
:str_helloWorld
    d8 $"Hello, world!"

include "palette.svm"
include "font.svm"